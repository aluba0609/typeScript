<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

//1.最简单的类
// function Person(){
//     this.name='张三';
//     this.age=20;
// }
// var p=new Person()

// //2.构造函数和原型链增加方法
// function Person(){
//     this.name='张三';
//     this.age=20;
//     this.run=function(){
//         alert(this.name+'在运动')
//     }
// }
// //原型链上面的属性会被多个实例共享 构造函数不会
// Person.prototype.sex='男';
// Person.prototype.work=function(){
//     alert(this.name+'在工作')
// }
// var p=new Person()
// // p.run()
// p.work()
// alert(p.sex)



//3.类型里面的静态方法
// function Person(){
//     this.name='张三';//属性
//     this.age=20;
//     this.run=function(){//实例方法 需要new后调用
//         alert(this.name+'在运动')
//     }
// }
// Person.getInfo=function(){
//     alert('我是静态方法')
// }
// //调用静态方法
// Person.getInfo()

//4.  es5的继承   对象冒充实现继承
// function Person(){
//     this.name='张三';//属性
//     this.age=20;
//     this.run=function(){//实例方法 需要new后调用
//         alert(this.name+'在运动')
//     }
// }
// Person.prototype.sex='男';
// Person.prototype.work=function(){
//     alert(this.name+'在工作')
// }


// //Web类 继承Person类  原型链+对象冒充的组合继承
// function Web(){
//     Person.call(this);//对象冒充实现继承
// }
// var w=new Web();
// w.run();//对象冒充可以继承构造函数里面的属性和方法  但是无法继承原型链里面的属性和方法

// alert(w.sex)//无法继承


// 5.  es5的继承   原型链实现继承
// function Person(){
//     this.name='张三';//属性
//     this.age=20;
//     this.run=function(){//实例方法 需要new后调用
//         alert(this.name+'在运动')
//     }
// }
// Person.prototype.sex='男';
// Person.prototype.work=function(){
//     alert(this.name+'在工作')
// }


// //Web类 继承Person类  原型链+对象冒充的组合继承
// function Web(){}
// Web.prototype=new Person() //原型链实现继承
// var w=new Web();
// w.run();//原型链可以继承构造函数里面的属性和方法  也继承原型链里面的属性和方法

// alert(w.sex)


// 6.  es5的继承   原型链实现继承
// function Person(name,age){
//     this.name=name;//属性
//     this.age=age;
//     this.run=function(){//实例方法 需要new后调用
//         alert(this.name+'在运动')
//     }
// }
// Person.prototype.sex='男';
// Person.prototype.work=function(){
//     alert(this.name+'在工作')
// }



// function Web(name,age){}
// Web.prototype=new Person()

// var w=new Web('赵四',20);//实例化子类的时候没法给父类传参
// w.run();


// 7.  es5的继承   原型链+对象冒充继承
// function Person(name,age){
//     this.name=name;//属性
//     this.age=age;
//     this.run=function(){//实例方法 需要new后调用
//         alert(this.name+'在运动')
//     }
// }
// Person.prototype.sex='男';
// Person.prototype.work=function(){
//     alert(this.name+'在工作')
// }



// function Web(name,age){
//     Person.call(this,name,age)//对象冒充继承 实例化子类可以给父类传参
// }
// Web.prototype=new Person()

// var w=new Web('赵四',20);//实例化子类的时候没法给父类传参
// w.run();


//8.原型链+对象冒充继承的另外一种方式

// function Person(name,age){
//     this.name=name;//属性
//     this.age=age;
//     this.run=function(){//实例方法 需要new后调用
//         alert(this.name+'在运动')
//     }
// }
// Person.prototype.sex='男';
// Person.prototype.work=function(){
//     alert(this.name+'在工作')
// }



// function Web(name,age){
//     Person.call(this,name,age)//对象冒充继承 实例化子类可以给父类传参
// }
// Web.prototype=Person.prototype 

// var w=new Web('赵四',20);//实例化子类的时候没法给父类传参
// w.run();























    </script>
</body>
</html>